<!doctype html>

<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>test</title>
</head>

<body>
    <div class="grid--masonry">
        <div class="box"> </div>
        <div class="box"> </div>
        <div class="box"> </div>
        <div class="box"> </div>
        <div class="box"> </div>
        <div class="box"> </div>
        <div class="box"> </div>
        <div class="box"> </div>
        <div class="box"> </div>
        <div class="box"> </div>
        <div class="box"> </div>
        <div class="box"> </div>
        <div class="box"> </div>
        <div class="box"> </div>
        <div class="box"> </div>
        <div class="box"> </div>
    </div>

    <style>
        .grid--masonry {
            display: grid;
            grid-template-rows: masonry;
            grid-template-columns: repeat(auto-fill, 100px);

            justify-content: center;
            grid-gap: 1em;
            padding: 1em;
        }

        .box {
            border: 2px solid;
            border-radius: 4px;
            box-shadow: 2px 2px 5px rgba(#000, .7);
        }
    </style>


    <script>
        things = document.querySelectorAll(".box");
        things.forEach(thing => {
            thing.style.height = 30 + Math.random() * 400 + "px";
        });

        // JS fallback for masonry
        let grids = [...document.querySelectorAll('.grid--masonry')];

        if (grids.length && getComputedStyle(grids[0]).gridTemplateRows !== 'masonry') {
            console.log("css masonry grid not supported, falling back to js.");

            grids = grids.map(grid => ({
                _el: grid,
                gap: parseFloat(getComputedStyle(grid).gridRowGap),
                items: [...grid.childNodes].filter(c => c.nodeType === 1),
                ncol: 0
            }));
        }

        function layout() {
            grids.forEach(grid => {
                if (grid._el != undefined) {
                    /* get the post-resize/ load number of columns */
                    let ncol = getComputedStyle(grid._el).gridTemplateColumns.split(' ').length;
                    console.log(grid.ncol, ncol);
                    if (grid.ncol !== ncol) {
                        console.log("rearanging");
                        /* update number of columns */
                        grid.ncol = ncol;

                        /* revert to initial positioning, no margin */
                        grid.items.forEach(c => c.style.removeProperty('margin-top'));

                        /* if we have more than one column */
                        if (grid.ncol > 1) {
                            grid.items.slice(ncol).forEach((c, i) => {
                                let prev_fin = grid.items[i].getBoundingClientRect().bottom /* bottom edge of item above */,
                                    curr_ini = c.getBoundingClientRect().top /* top edge of current item */;

                                c.style.marginTop = `${prev_fin + grid.gap - curr_ini}px`;
                            });
                        }
                    }
                }
            });
        }

        addEventListener('load', e => {
            layout(); /* initial load */
            addEventListener('resize', layout, false);
        }, false);
    </script>
</body>
